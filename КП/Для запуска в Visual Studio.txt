#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#define CSC(call)                                                                                       \
do {                                                                                                        \
        cudaError_t res = call;                                                                 \
        if (res != cudaSuccess) {                                                                   \
                fprintf(stderr, "ERROR in %s:%d. Message: %s\n",                        \
                                __FILE__, __LINE__, cudaGetErrorString(res));           \
                exit(0);                                                                                    \
        }                                                                                                       \
} while(0)


typedef unsigned char uchar;


#define M_PI 3.1415926536

struct vec3 {
    double x;
    double y;
    double z;
};

__host__ __device__ double dot(vec3 a, vec3 b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

__host__ __device__ vec3 prod(vec3 a, vec3 b) {
    return { a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z,  a.x * b.y - a.y * b.x };
}

__host__ __device__ vec3 norm(vec3 v) {
    double l = sqrt(dot(v, v));
    return { v.x / l, v.y / l, v.z / l };
}

__host__ __device__ vec3 diff(vec3 a, vec3 b) {
    return { a.x - b.x, a.y - b.y, a.z - b.z };
}

__host__ __device__ vec3 add(vec3 a, vec3 b) {
    return { a.x + b.x, a.y + b.y, a.z + b.z };
}

__host__ __device__ vec3 mult(vec3 a, vec3 b, vec3 c, vec3 v) {
    return { a.x * v.x + b.x * v.y + c.x * v.z,
                    a.y * v.x + b.y * v.y + c.y * v.z,
                    a.z * v.x + b.z * v.y + c.z * v.z };
}

__host__ __device__ vec3 to_normal(double r, double phi, double z) {
    return { r * cos(phi), r * sin(phi), z };
}

void print(vec3 v) {
    printf("%e %e %e\n", v.x, v.y, v.z);
}

vec3 dots3_1[60];

void make_points_icos(vec3 a, vec3 b, vec3 c, double d, int i) {
    vec3 norma = prod(diff(b, a), diff(c, a));
    norma = norm(norma);
    norma = { norma.x * d, norma.y * d, norma.z * d };

    dots3_1[i] = { a.x + norma.x, a.y + norma.y, a.z + norma.z };
    dots3_1[i + 1] = { b.x + norma.x, b.y + norma.y, b.z + norma.z };
    dots3_1[i + 2] = { c.x + norma.x, c.y + norma.y, c.z + norma.z };
}


struct trig {
    vec3 a;
    vec3 b;
    vec3 c;
    double4 color;
    double coef_refl;
    double coef_transp;
    bool is_edge = false;
    int pair = 0;
    int number_of_lights = 0;
    bool is_floor = false;
    double4 clr_floor = { 0.0, 0.0, 0.0, 255 };
};

struct hit {
    vec3 pos;
    vec3 normal;
    int num_of_trig;
};

struct ray {
    vec3 pos;
    vec3 dir;
    int id;
    double coef;
};

struct light {
    vec3 pos;
    double4 color;
};


trig* trigs;
int N = 207;

light* lights;
int light_numb;

uchar4* floor_text;
int w_f, h_f;

int build_space(vec3 c1, double4 clr1, double r1, double coef_refl1, double coef_transp1, int number_of_lights1,
    vec3 c2, double4 clr2, double r2, double coef_refl2, double coef_transp2, int number_of_lights2,
    vec3 c3, double4 clr3, double r3, double coef_refl3, double coef_transp3, int number_of_lights3,
    vec3 pnt1, vec3 pnt2, vec3 pnt3, vec3 pnt4, double4 clr_fl, double coef_fl, char* floor_path) {

    //пол

    FILE* in = fopen(floor_path, "rb");

    if (in == NULL) {
        return 2;
    }

    fread(&w_f, sizeof(int), 1, in);
    fread(&h_f, sizeof(int), 1, in);
    floor_text = (uchar4*)malloc(sizeof(uchar4) * w_f * h_f);
    fread(floor_text, sizeof(uchar4), w_f * h_f, in);
    fclose(in);

    trigs[0] = {pnt4, pnt3, pnt2, clr_fl, coef_fl, 0.0};
    trigs[1] = { pnt1, pnt4, pnt2, clr_fl, coef_fl, 0.0 };

    trigs[0].is_floor = true;
    trigs[1].is_floor = true;

    trigs[0].clr_floor = clr_fl;
    trigs[1].clr_floor = clr_fl;


    //грани фигур

    double4 clr4 = { 13.0 / 255.0, 42.0 / 255.0, 54.0 / 255.0, 255.0 };
    double coef_refl4 = 0.5;
    double coef_transp4 = 0.0;


    //гексаэдр

    double a1 = r1 / sqrt(3.0); // половина сторона куба
    double d = a1 / 10.0;     // ширина грани

    // точки гексаэдра
    vec3 dots1[24] = {
        //сдвиг по x
        {c1.x + a1, c1.y + a1 - d, c1.z + a1 - d},
        {c1.x + a1, c1.y + a1 - d, c1.z - a1 + d},
        {c1.x + a1, c1.y - a1 + d, c1.z + a1 - d},
        {c1.x + a1, c1.y - a1 + d, c1.z - a1 + d},

        {c1.x - a1, c1.y + a1 - d, c1.z + a1 - d},
        {c1.x - a1, c1.y + a1 - d, c1.z - a1 + d},
        {c1.x - a1, c1.y - a1 + d, c1.z + a1 - d},
        {c1.x - a1, c1.y - a1 + d, c1.z - a1 + d},

        //сдвиг по y

        {c1.x + a1 - d, c1.y + a1, c1.z + a1 - d},
        {c1.x + a1 - d, c1.y + a1, c1.z - a1 + d},
        {c1.x - a1 + d, c1.y + a1, c1.z + a1 - d},
        {c1.x - a1 + d, c1.y + a1, c1.z - a1 + d},

        {c1.x + a1 - d, c1.y - a1, c1.z + a1 - d},
        {c1.x + a1 - d, c1.y - a1, c1.z - a1 + d},
        {c1.x - a1 + d, c1.y - a1, c1.z + a1 - d},
        {c1.x - a1 + d, c1.y - a1, c1.z - a1 + d},

        //сдвиг по z

        {c1.x + a1 - d, c1.y + a1 - d, c1.z + a1},
        {c1.x + a1 - d, c1.y - a1 + d, c1.z + a1},
        {c1.x - a1 + d, c1.y + a1 - d, c1.z + a1},
        {c1.x - a1 + d, c1.y - a1 + d, c1.z + a1},

        {c1.x + a1 - d, c1.y + a1 - d, c1.z - a1},
        {c1.x + a1 - d, c1.y - a1 + d, c1.z - a1},
        {c1.x - a1 + d, c1.y + a1 - d, c1.z - a1},
        {c1.x - a1 + d, c1.y - a1 + d, c1.z - a1},

    };

    //грани

    trigs[2] = {dots1[0], dots1[2], dots1[1],  clr1, coef_refl1, coef_transp1};
    trigs[3] = {dots1[3], dots1[1], dots1[2],  clr1, coef_refl1, coef_transp1};

    trigs[4] = { dots1[4], dots1[5], dots1[6],  clr1, coef_refl1, coef_transp1 };
    trigs[5] = { dots1[7], dots1[6], dots1[5],  clr1, coef_refl1, coef_transp1 };

    trigs[6] = { dots1[8], dots1[9], dots1[10],  clr1, coef_refl1, coef_transp1 };
    trigs[7] = { dots1[11], dots1[10], dots1[9],  clr1, coef_refl1, coef_transp1 };

    trigs[8] = { dots1[12], dots1[14], dots1[13],  clr1, coef_refl1, coef_transp1 };
    trigs[9] = { dots1[15], dots1[13], dots1[14],  clr1, coef_refl1, coef_transp1 };

    trigs[10] = { dots1[16], dots1[18], dots1[17],  clr1, coef_refl1, coef_transp1 };
    trigs[11] = { dots1[19], dots1[17], dots1[18],  clr1, coef_refl1, coef_transp1 };

    trigs[12] = { dots1[20], dots1[21], dots1[22],  clr1, coef_refl1, coef_transp1 };
    trigs[13] = { dots1[23], dots1[22], dots1[21],  clr1, coef_refl1, coef_transp1 };

    //точки

    trigs[14] = {dots1[1], dots1[20], dots1[9],  clr4, coef_refl1, coef_transp1};
    trigs[15] = { dots1[3], dots1[13], dots1[21],  clr4, coef_refl1, coef_transp1 };

    trigs[16] = { dots1[16], dots1[0], dots1[8],  clr4, coef_refl1, coef_transp1 };
    trigs[17] = { dots1[17], dots1[12], dots1[2],  clr4, coef_refl1, coef_transp1 };

    trigs[18] = { dots1[19], dots1[6], dots1[14],  clr4, coef_refl1, coef_transp1 };
    trigs[19] = { dots1[18], dots1[10], dots1[4],  clr4, coef_refl1, coef_transp1 };

    trigs[20] = { dots1[7], dots1[23], dots1[15],  clr4, coef_refl1, coef_transp1 };
    trigs[21] = { dots1[5], dots1[11], dots1[22],  clr4, coef_refl1, coef_transp1 };

    //рёбра

    d = d / 2;

    trigs[22] = { dots1[0], dots1[1], dots1[8], clr4, coef_refl4, coef_transp4, true, 23, number_of_lights1 };
    trigs[23] = { dots1[9], dots1[8], dots1[1], clr4, coef_refl4, coef_transp4, true, 22, number_of_lights1 };

    trigs[24] = { dots1[2], dots1[0], dots1[17], clr4, coef_refl4, coef_transp4, true, 25, number_of_lights1 };
    trigs[25] = { dots1[16], dots1[17], dots1[0], clr4, coef_refl4, coef_transp4, true, 24, number_of_lights1 };

    trigs[26] = { dots1[1], dots1[3], dots1[20], clr4, coef_refl4, coef_transp4, true, 27, number_of_lights1 };
    trigs[27] = { dots1[21], dots1[20], dots1[3], clr4, coef_refl4, coef_transp4, true, 26, number_of_lights1 };

    trigs[28] = { dots1[12], dots1[13], dots1[2], clr4, coef_refl4, coef_transp4, true, 29, number_of_lights1 };
    trigs[29] = { dots1[3], dots1[2], dots1[13], clr4, coef_refl4, coef_transp4, true, 28, number_of_lights1 };


    trigs[30] = { dots1[10], dots1[11], dots1[4], clr4, coef_refl4, coef_transp4, true, 31, number_of_lights1 };
    trigs[31] = { dots1[5], dots1[4], dots1[11], clr4, coef_refl4, coef_transp4, true, 30, number_of_lights1 };

    trigs[32] = { dots1[4], dots1[6], dots1[18], clr4, coef_refl4, coef_transp4, true, 33, number_of_lights1 };
    trigs[33] = { dots1[19], dots1[18], dots1[6], clr4, coef_refl4, coef_transp4, true, 32, number_of_lights1 };

    trigs[34] = { dots1[22], dots1[23], dots1[5], clr4, coef_refl4, coef_transp4, true, 35, number_of_lights1 };
    trigs[35] = { dots1[7], dots1[5], dots1[23], clr4, coef_refl4, coef_transp4, true, 34, number_of_lights1 };

    trigs[36] = { dots1[6], dots1[7], dots1[14], clr4, coef_refl4, coef_transp4, true, 37, number_of_lights1 };
    trigs[37] = { dots1[15], dots1[14], dots1[7], clr4, coef_refl4, coef_transp4, true, 36, number_of_lights1 };


    trigs[38] = { dots1[20], dots1[22], dots1[9], clr4, coef_refl4, coef_transp4, true, 39, number_of_lights1 };
    trigs[39] = { dots1[11], dots1[9], dots1[22], clr4, coef_refl4, coef_transp4, true, 38, number_of_lights1 };

    trigs[40] = { dots1[8], dots1[10], dots1[16], clr4, coef_refl4, coef_transp4, true, 41, number_of_lights1 };
    trigs[41] = { dots1[18], dots1[16], dots1[10], clr4, coef_refl4, coef_transp4, true, 40, number_of_lights1 };


    trigs[42] = { dots1[13], dots1[15], dots1[21], clr4, coef_refl4, coef_transp4, true, 43, number_of_lights1 };
    trigs[43] = { dots1[23], dots1[21], dots1[15], clr4, coef_refl4, coef_transp4, true, 42, number_of_lights1 };

    trigs[44] = { dots1[14], dots1[12], dots1[19], clr4, coef_refl4, coef_transp4, true, 45, number_of_lights1 };
    trigs[45] = { dots1[17], dots1[19], dots1[12], clr4, coef_refl4, coef_transp4, true, 44, number_of_lights1 };

    //октаэдр

    double a2 = r2 * sqrt(2.0) / 2.0;   // половина стороны октаэдра
    d = a2 / 20.0;

    // точки октаэдра
    vec3 dots2[24] = {
            {c2.x + d, c2.y, c2.z + r2 - d * sqrt(2)},
            {c2.x, c2.y + d, c2.z + r2 - d * sqrt(2)},
            {c2.x, c2.y - d, c2.z + r2 - d * sqrt(2)},
            {c2.x - d, c2.y, c2.z + r2 - d * sqrt(2)},

            {c2.x + d, c2.y, c2.z - r2 + d * sqrt(2)},
            {c2.x, c2.y + d, c2.z - r2 + d * sqrt(2)},
            {c2.x, c2.y - d, c2.z - r2 + d * sqrt(2)},
            {c2.x - d, c2.y, c2.z - r2 + d * sqrt(2)},

            {c2.x + a2 - d * sqrt(2), c2.y + a2, c2.z + d},
            {c2.x + a2 - d * sqrt(2), c2.y + a2, c2.z - d},
            {c2.x + a2, c2.y + a2 - d * sqrt(2), c2.z + d},
            {c2.x + a2, c2.y + a2 - d * sqrt(2), c2.z - d},

            {c2.x + a2 - d * sqrt(2), c2.y - a2, c2.z + d},
            {c2.x + a2 - d * sqrt(2), c2.y - a2, c2.z - d},
            {c2.x + a2, c2.y - a2 + d * sqrt(2), c2.z + d},
            {c2.x + a2, c2.y - a2 + d * sqrt(2), c2.z - d},

            {c2.x - a2 + d * sqrt(2), c2.y + a2, c2.z + d},
            {c2.x - a2 + d * sqrt(2), c2.y + a2, c2.z - d},
            {c2.x - a2, c2.y + a2 - d * sqrt(2), c2.z + d},
            {c2.x - a2, c2.y + a2 - d * sqrt(2), c2.z - d},

            {c2.x - a2 + d * sqrt(2), c2.y - a2, c2.z + d},
            {c2.x - a2 + d * sqrt(2), c2.y - a2, c2.z - d},
            {c2.x - a2, c2.y - a2 + d * sqrt(2), c2.z + d},
            {c2.x - a2, c2.y - a2 + d * sqrt(2), c2.z - d},
    };

    //вершины

    trigs[46] = { dots2[0], dots2[1], dots2[2], clr4, coef_refl4, coef_transp4 };
    trigs[47] = { dots2[3], dots2[2], dots2[1], clr4, coef_refl4, coef_transp4 };

    trigs[48] = { dots2[4], dots2[6], dots2[5], clr4, coef_refl4, coef_transp4 };
    trigs[49] = { dots2[7], dots2[5], dots2[6], clr4, coef_refl4, coef_transp4 };

    trigs[50] = { dots2[8], dots2[10], dots2[9], clr4, coef_refl4, coef_transp4 };
    trigs[51] = { dots2[11], dots2[9], dots2[10], clr4, coef_refl4, coef_transp4 };

    trigs[52] = { dots2[14], dots2[12], dots2[15], clr4, coef_refl4, coef_transp4 };
    trigs[53] = { dots2[13], dots2[15], dots2[12], clr4, coef_refl4, coef_transp4 };

    trigs[54] = { dots2[16], dots2[17], dots2[18], clr4, coef_refl4, coef_transp4 };
    trigs[55] = { dots2[19], dots2[18], dots2[17], clr4, coef_refl4, coef_transp4 };

    trigs[56] = { dots2[20], dots2[23], dots2[21], clr4, coef_refl4, coef_transp4 };
    trigs[57] = { dots2[23], dots2[21], dots2[22], clr4, coef_refl4, coef_transp4 };

    //рёбра

    trigs[58] = { dots2[0], dots2[10], dots2[1], clr4, coef_refl4, coef_transp4, true, 59, number_of_lights2 };
    trigs[59] = { dots2[8], dots2[1], dots2[10], clr4, coef_refl4, coef_transp4, true, 58, number_of_lights2 };

    trigs[60] = { dots2[2], dots2[12], dots2[0], clr4, coef_refl4, coef_transp4, true, 61, number_of_lights2 };
    trigs[61] = { dots2[14], dots2[0], dots2[12], clr4, coef_refl4, coef_transp4, true, 60, number_of_lights2 };

    trigs[62] = { dots2[18], dots2[3], dots2[16], clr4, coef_refl4, coef_transp4, true, 63, number_of_lights2 };
    trigs[63] = { dots2[1], dots2[16], dots2[3], clr4, coef_refl4, coef_transp4, true, 62, number_of_lights2 };

    trigs[64] = { dots2[3], dots2[22], dots2[2], clr4, coef_refl4, coef_transp4, true, 65, number_of_lights2 };
    trigs[65] = { dots2[20], dots2[2], dots2[22], clr4, coef_refl4, coef_transp4, true, 64, number_of_lights2 };


    trigs[66] = { dots2[11], dots2[4], dots2[9], clr4, coef_refl4, coef_transp4, true, 67, number_of_lights2 };
    trigs[67] = { dots2[5], dots2[9], dots2[4], clr4, coef_refl4, coef_transp4, true, 66, number_of_lights2 };

    trigs[68] = { dots2[4], dots2[15], dots2[6], clr4, coef_refl4, coef_transp4, true, 69, number_of_lights2 };
    trigs[69] = { dots2[13], dots2[6], dots2[15], clr4, coef_refl4, coef_transp4, true, 68, number_of_lights2 };

    trigs[70] = { dots2[7], dots2[19], dots2[5], clr4, coef_refl4, coef_transp4, true, 71, number_of_lights2 };
    trigs[71] = { dots2[17], dots2[5], dots2[19], clr4, coef_refl4, coef_transp4, true, 70, number_of_lights2 };

    trigs[72] = { dots2[23], dots2[7], dots2[21], clr4, coef_refl4, coef_transp4, true, 73, number_of_lights2 };
    trigs[73] = { dots2[6], dots2[21], dots2[7], clr4, coef_refl4, coef_transp4, true, 72, number_of_lights2 };


    trigs[74] = { dots2[10], dots2[14], dots2[11], clr4, coef_refl4, coef_transp4, true, 75, number_of_lights2 };
    trigs[75] = { dots2[15], dots2[11], dots2[14], clr4, coef_refl4, coef_transp4, true, 74, number_of_lights2 };

    trigs[76] = { dots2[12], dots2[20], dots2[13], clr4, coef_refl4, coef_transp4, true, 77, number_of_lights2 };
    trigs[77] = { dots2[21], dots2[13], dots2[20], clr4, coef_refl4, coef_transp4, true, 76, number_of_lights2 };

    trigs[78] = { dots2[22], dots2[18], dots2[23], clr4, coef_refl4, coef_transp4, true, 79, number_of_lights2 };
    trigs[79] = { dots2[19], dots2[23], dots2[18], clr4, coef_refl4, coef_transp4, true, 78, number_of_lights2 };

    trigs[80] = { dots2[16], dots2[8], dots2[17], clr4, coef_refl4, coef_transp4, true, 81, number_of_lights2 };
    trigs[81] = { dots2[9], dots2[17], dots2[8], clr4, coef_refl4, coef_transp4, true, 80, number_of_lights2 };

    //грани
    trigs[82] = { dots2[0], dots2[14], dots2[10], clr2, coef_refl2, coef_transp2 };
    trigs[83] = { dots2[4], dots2[11], dots2[15], clr2, coef_refl2, coef_transp2 };

    trigs[84] = { dots2[1], dots2[8], dots2[16], clr2, coef_refl2, coef_transp2 };
    trigs[85] = { dots2[5], dots2[17], dots2[9], clr2, coef_refl2, coef_transp2 };

    trigs[86] = { dots2[3], dots2[18], dots2[22], clr2, coef_refl2, coef_transp2 };
    trigs[87] = { dots2[7], dots2[23], dots2[19], clr2, coef_refl2, coef_transp2 };

    trigs[88] = { dots2[2], dots2[20], dots2[12], clr2, coef_refl2, coef_transp2 };
    trigs[89] = { dots2[6], dots2[13], dots2[21], clr2, coef_refl2, coef_transp2 };


    //икосаэдр

    double phi = (1.0 + sqrt(5.0)) / 2.0; // золотое сечение

    // точки икосаэдра
    vec3 dots3[12] = {
            {phi, 1, 0},

            {phi, -1, 0},
            {1, 0, phi},
            {0, phi, 1},
            {0, phi, -1},
            {1, 0, -phi},


            {-phi, -1, 0},

            {0, -phi, 1},
            {-1, 0, phi},
            {-phi, 1, 0},
            {-1, 0, -phi},
            {0, -phi, -1}
    };

    for (int i = 0; i < 12; i++) {
        // продолжение формулы для координат икосаэдра с центром (0, 0, 0) и радиусом описанной окружности 1
        dots3[i].x = dots3[i].x / sqrt(1 + phi * phi);
        dots3[i].y = dots3[i].y / sqrt(1 + phi * phi);
        dots3[i].z = dots3[i].z / sqrt(1 + phi * phi);
        // приводим в соответствие для нашего радиуса
        dots3[i].x = dots3[i].x * r3;
        dots3[i].y = dots3[i].y * r3;
        dots3[i].z = dots3[i].z * r3;
        // смещаем в наш центр
        dots3[i].x = dots3[i].x + c3.x;
        dots3[i].y = dots3[i].y + c3.y;
        dots3[i].z = dots3[i].z + c3.z;
    }

    //грани

    d = r3 / 10.0;

    if (d > 1.0) {
        d = 1.0 / d;
    }

    // новые точки икосаэдра, учитывая ширину граней

    make_points_icos(dots3[1], dots3[0], dots3[2], d, 0);
    make_points_icos(dots3[0], dots3[3], dots3[2], d, 3);
    make_points_icos(dots3[2], dots3[3], dots3[8], d, 6);
    make_points_icos(dots3[8], dots3[9], dots3[6], d, 9);
    make_points_icos(dots3[6], dots3[10], dots3[11], d, 12);
    make_points_icos(dots3[11], dots3[5], dots3[1], d, 15);
    make_points_icos(dots3[1], dots3[5], dots3[0], d, 18);
    make_points_icos(dots3[8], dots3[3], dots3[9], d, 21);
    make_points_icos(dots3[6], dots3[9], dots3[10], d, 24);
    make_points_icos(dots3[11], dots3[10], dots3[5], d, 27);

    make_points_icos(dots3[7], dots3[1], dots3[2], d, 30);
    make_points_icos(dots3[7], dots3[2], dots3[8], d, 33);
    make_points_icos(dots3[7], dots3[8], dots3[6], d, 36);
    make_points_icos(dots3[7], dots3[6], dots3[11], d, 39);
    make_points_icos(dots3[7], dots3[11], dots3[1], d, 42);

    make_points_icos(dots3[4], dots3[0], dots3[5], d, 45);
    make_points_icos(dots3[4], dots3[5], dots3[10], d, 48);
    make_points_icos(dots3[4], dots3[10], dots3[9], d, 51);
    make_points_icos(dots3[4], dots3[9], dots3[3], d, 54);
    make_points_icos(dots3[4], dots3[3], dots3[0], d, 57);

    // грани

    for (int i = 0; i < 60;i = i + 3) {
        trigs[90 + i / 3] = { dots3_1[i], dots3_1[i + 1], dots3_1[i + 2], clr3, coef_refl3, coef_transp3 };
    }

    // вершины

    trigs[111] = {dots3_1[55], dots3_1[10], dots3_1[23], clr4, coef_refl4, coef_transp4};
    trigs[112] = { dots3_1[55], dots3_1[25], dots3_1[10], clr4, coef_refl4, coef_transp4 };
    trigs[113] = { dots3_1[55], dots3_1[53], dots3_1[25], clr4, coef_refl4, coef_transp4 };

    trigs[114] = { dots3_1[24], dots3_1[38], dots3_1[11], clr4, coef_refl4, coef_transp4 };
    trigs[115] = { dots3_1[24], dots3_1[40], dots3_1[38], clr4, coef_refl4, coef_transp4 };
    trigs[116] = { dots3_1[25], dots3_1[12], dots3_1[40], clr4, coef_refl4, coef_transp4 };

    trigs[117] = { dots3_1[39], dots3_1[33], dots3_1[36], clr4, coef_refl4, coef_transp4 };
    trigs[118] = { dots3_1[39], dots3_1[30], dots3_1[33], clr4, coef_refl4, coef_transp4 };
    trigs[119] = { dots3_1[39], dots3_1[42], dots3_1[30], clr4, coef_refl4, coef_transp4 };

    trigs[120] = { dots3_1[32], dots3_1[6], dots3_1[34], clr4, coef_refl4, coef_transp4 };
    trigs[121] = { dots3_1[32], dots3_1[5], dots3_1[6], clr4, coef_refl4, coef_transp4 };
    trigs[122] = { dots3_1[32], dots3_1[2], dots3_1[5], clr4, coef_refl4, coef_transp4 };

    trigs[123] = { dots3_1[4], dots3_1[22], dots3_1[7], clr4, coef_refl4, coef_transp4 };
    trigs[124] = { dots3_1[4], dots3_1[56], dots3_1[22], clr4, coef_refl4, coef_transp4 };
    trigs[125] = { dots3_1[4], dots3_1[58], dots3_1[56], clr4, coef_refl4, coef_transp4 };

    trigs[126] = { dots3_1[8], dots3_1[37], dots3_1[35], clr4, coef_refl4, coef_transp4 };
    trigs[127] = { dots3_1[8], dots3_1[9], dots3_1[37], clr4, coef_refl4, coef_transp4 };
    trigs[128] = { dots3_1[8], dots3_1[21], dots3_1[9], clr4, coef_refl4, coef_transp4 };

    trigs[129] = { dots3_1[45], dots3_1[54], dots3_1[57], clr4, coef_refl4, coef_transp4 };
    trigs[130] = { dots3_1[45], dots3_1[51], dots3_1[54], clr4, coef_refl4, coef_transp4 };
    trigs[131] = { dots3_1[45], dots3_1[48], dots3_1[51], clr4, coef_refl4, coef_transp4 };

    trigs[132] = { dots3_1[27], dots3_1[41], dots3_1[14], clr4, coef_refl4, coef_transp4 };
    trigs[133] = { dots3_1[27], dots3_1[43], dots3_1[41], clr4, coef_refl4, coef_transp4 };
    trigs[134] = { dots3_1[27], dots3_1[15], dots3_1[43], clr4, coef_refl4, coef_transp4 };

    trigs[135] = { dots3_1[17], dots3_1[31], dots3_1[44], clr4, coef_refl4, coef_transp4 };
    trigs[136] = { dots3_1[17], dots3_1[0], dots3_1[31], clr4, coef_refl4, coef_transp4 };
    trigs[137] = { dots3_1[17], dots3_1[18], dots3_1[0], clr4, coef_refl4, coef_transp4 };

    trigs[138] = { dots3_1[20], dots3_1[3], dots3_1[1], clr4, coef_refl4, coef_transp4 };
    trigs[139] = { dots3_1[20], dots3_1[59], dots3_1[3], clr4, coef_refl4, coef_transp4 };
    trigs[140] = { dots3_1[20], dots3_1[46], dots3_1[59], clr4, coef_refl4, coef_transp4 };

    trigs[141] = { dots3_1[50], dots3_1[26], dots3_1[52], clr4, coef_refl4, coef_transp4 };
    trigs[142] = { dots3_1[50], dots3_1[13], dots3_1[26], clr4, coef_refl4, coef_transp4 };
    trigs[143] = { dots3_1[50], dots3_1[28], dots3_1[13], clr4, coef_refl4, coef_transp4 };

    trigs[144] = { dots3_1[29], dots3_1[19], dots3_1[16], clr4, coef_refl4, coef_transp4 };
    trigs[145] = { dots3_1[29], dots3_1[47], dots3_1[19], clr4, coef_refl4, coef_transp4 };
    trigs[146] = { dots3_1[19], dots3_1[49], dots3_1[47], clr4, coef_refl4, coef_transp4 };

    // рёбра

    trigs[147] = {dots3_1[44], dots3_1[43], dots3_1[17], clr4, coef_refl4, coef_transp4, true, 148, number_of_lights3 };
    trigs[148] = { dots3_1[15], dots3_1[17], dots3_1[43], clr4, coef_refl4, coef_transp4, true, 147, number_of_lights3 };

    trigs[149] = { dots3_1[17], dots3_1[16], dots3_1[18], clr4, coef_refl4, coef_transp4, true, 150, number_of_lights3 };
    trigs[150] = { dots3_1[19], dots3_1[18], dots3_1[16], clr4, coef_refl4, coef_transp4, true, 149, number_of_lights3 };

    trigs[151] = { dots3_1[18], dots3_1[20], dots3_1[0], clr4, coef_refl4, coef_transp4, true, 152, number_of_lights3 };
    trigs[152] = { dots3_1[1], dots3_1[0], dots3_1[20], clr4, coef_refl4, coef_transp4, true, 151, number_of_lights3 };

    trigs[153] = { dots3_1[0], dots3_1[2], dots3_1[31], clr4, coef_refl4, coef_transp4, true, 154, number_of_lights3 };
    trigs[154] = { dots3_1[32], dots3_1[31], dots3_1[2], clr4, coef_refl4, coef_transp4, true, 153, number_of_lights3 };

    trigs[155] = { dots3_1[31], dots3_1[30], dots3_1[44], clr4, coef_refl4, coef_transp4, true, 156, number_of_lights3 };
    trigs[156] = { dots3_1[42], dots3_1[44], dots3_1[30], clr4, coef_refl4, coef_transp4, true, 155, number_of_lights3 };


    trigs[157] = { dots3_1[39], dots3_1[41], dots3_1[42], clr4, coef_refl4, coef_transp4, true, 158, number_of_lights3 };
    trigs[158] = { dots3_1[43], dots3_1[42], dots3_1[41], clr4, coef_refl4, coef_transp4, true, 157, number_of_lights3 };

    trigs[159] = { dots3_1[27], dots3_1[29], dots3_1[15], clr4, coef_refl4, coef_transp4, true, 160, number_of_lights3 };
    trigs[160] = { dots3_1[16], dots3_1[15], dots3_1[29], clr4, coef_refl4, coef_transp4, true, 159, number_of_lights3 };

    trigs[161] = { dots3_1[47], dots3_1[46], dots3_1[19], clr4, coef_refl4, coef_transp4, true, 162, number_of_lights3 };
    trigs[162] = { dots3_1[20], dots3_1[19], dots3_1[46], clr4, coef_refl4, coef_transp4, true, 161, number_of_lights3 };

    trigs[163] = { dots3_1[3], dots3_1[5], dots3_1[1], clr4, coef_refl4, coef_transp4, true, 164, number_of_lights3 };
    trigs[164] = { dots3_1[2], dots3_1[1], dots3_1[5], clr4, coef_refl4, coef_transp4, true, 163, number_of_lights3 };

    trigs[165] = { dots3_1[34], dots3_1[33], dots3_1[32], clr4, coef_refl4, coef_transp4, true, 166, number_of_lights3 };
    trigs[166] = { dots3_1[30], dots3_1[32], dots3_1[33], clr4, coef_refl4, coef_transp4, true, 165, number_of_lights3 };


    trigs[167] = { dots3_1[33], dots3_1[35], dots3_1[36], clr4, coef_refl4, coef_transp4, true, 168, number_of_lights3 };
    trigs[168] = { dots3_1[37], dots3_1[36], dots3_1[35], clr4, coef_refl4, coef_transp4, true, 167, number_of_lights3 };

    trigs[169] = { dots3_1[41], dots3_1[40], dots3_1[14], clr4, coef_refl4, coef_transp4, true, 170, number_of_lights3 };
    trigs[170] = { dots3_1[12], dots3_1[14], dots3_1[40], clr4, coef_refl4, coef_transp4, true, 169, number_of_lights3 };

    trigs[171] = { dots3_1[29], dots3_1[28], dots3_1[49], clr4, coef_refl4, coef_transp4, true, 172, number_of_lights3 };
    trigs[172] = { dots3_1[50], dots3_1[49], dots3_1[28], clr4, coef_refl4, coef_transp4, true, 171, number_of_lights3 };

    trigs[173] = { dots3_1[46], dots3_1[45], dots3_1[59], clr4, coef_refl4, coef_transp4, true, 174, number_of_lights3 };
    trigs[174] = { dots3_1[57], dots3_1[59], dots3_1[45], clr4, coef_refl4, coef_transp4, true, 173, number_of_lights3 };

    trigs[175] = { dots3_1[5], dots3_1[4], dots3_1[6], clr4, coef_refl4, coef_transp4, true, 176, number_of_lights3 };
    trigs[176] = { dots3_1[7], dots3_1[6], dots3_1[4], clr4, coef_refl4, coef_transp4, true, 175, number_of_lights3 };


    trigs[177] = { dots3_1[36], dots3_1[38], dots3_1[39], clr4, coef_refl4, coef_transp4, true, 178, number_of_lights3 };
    trigs[178] = { dots3_1[40], dots3_1[39], dots3_1[38], clr4, coef_refl4, coef_transp4, true, 177, number_of_lights3 };

    trigs[179] = { dots3_1[14], dots3_1[13], dots3_1[27], clr4, coef_refl4, coef_transp4, true, 180, number_of_lights3 };
    trigs[180] = { dots3_1[28], dots3_1[27], dots3_1[13], clr4, coef_refl4, coef_transp4, true, 179, number_of_lights3 };

    trigs[181] = { dots3_1[49], dots3_1[48], dots3_1[47], clr4, coef_refl4, coef_transp4, true, 182, number_of_lights3 };
    trigs[182] = { dots3_1[45], dots3_1[47], dots3_1[48], clr4, coef_refl4, coef_transp4, true, 181, number_of_lights3 };

    trigs[183] = { dots3_1[59], dots3_1[58], dots3_1[3], clr4, coef_refl4, coef_transp4, true, 184, number_of_lights3 };
    trigs[184] = { dots3_1[4], dots3_1[3], dots3_1[58], clr4, coef_refl4, coef_transp4, true, 183, number_of_lights3 };

    trigs[185] = { dots3_1[6], dots3_1[8], dots3_1[34], clr4, coef_refl4, coef_transp4, true, 186, number_of_lights3 };
    trigs[186] = { dots3_1[35], dots3_1[34], dots3_1[8], clr4, coef_refl4, coef_transp4, true, 185, number_of_lights3 };


    trigs[187] = { dots3_1[9], dots3_1[11], dots3_1[37], clr4, coef_refl4, coef_transp4, true, 188, number_of_lights3 };
    trigs[188] = { dots3_1[38], dots3_1[37], dots3_1[11], clr4, coef_refl4, coef_transp4, true, 187, number_of_lights3 };

    trigs[189] = { dots3_1[24], dots3_1[26], dots3_1[12], clr4, coef_refl4, coef_transp4, true, 190, number_of_lights3 };
    trigs[190] = { dots3_1[13], dots3_1[12], dots3_1[26], clr4, coef_refl4, coef_transp4, true, 189, number_of_lights3 };

    trigs[191] = { dots3_1[52], dots3_1[51], dots3_1[50], clr4, coef_refl4, coef_transp4, true, 192, number_of_lights3 };
    trigs[192] = { dots3_1[48], dots3_1[50], dots3_1[51], clr4, coef_refl4, coef_transp4, true, 191, number_of_lights3 };

    trigs[193] = { dots3_1[54], dots3_1[56], dots3_1[57], clr4, coef_refl4, coef_transp4, true, 194, number_of_lights3 };
    trigs[194] = { dots3_1[58], dots3_1[57], dots3_1[56], clr4, coef_refl4, coef_transp4, true, 193, number_of_lights3 };

    trigs[195] = { dots3_1[22], dots3_1[21], dots3_1[7], clr4, coef_refl4, coef_transp4, true, 196, number_of_lights3 };
    trigs[196] = { dots3_1[8], dots3_1[7], dots3_1[21], clr4, coef_refl4, coef_transp4, true, 195, number_of_lights3 };


    trigs[197] = { dots3_1[25], dots3_1[24], dots3_1[10], clr4, coef_refl4, coef_transp4, true, 198, number_of_lights3 };
    trigs[198] = { dots3_1[11], dots3_1[10], dots3_1[24], clr4, coef_refl4, coef_transp4, true, 197, number_of_lights3 };

    trigs[199] = { dots3_1[10], dots3_1[9], dots3_1[23], clr4, coef_refl4, coef_transp4, true, 200, number_of_lights3 };
    trigs[200] = { dots3_1[21], dots3_1[23], dots3_1[9], clr4, coef_refl4, coef_transp4, true, 199, number_of_lights3 };

    trigs[201] = { dots3_1[23], dots3_1[22], dots3_1[55], clr4, coef_refl4, coef_transp4, true, 202, number_of_lights3 };
    trigs[202] = { dots3_1[56], dots3_1[55], dots3_1[22], clr4, coef_refl4, coef_transp4, true, 201, number_of_lights3 };

    trigs[203] = { dots3_1[55], dots3_1[54], dots3_1[53], clr4, coef_refl4, coef_transp4, true, 204, number_of_lights3 };
    trigs[204] = { dots3_1[51], dots3_1[53], dots3_1[54], clr4, coef_refl4, coef_transp4, true, 203, number_of_lights3 };

    trigs[205] = { dots3_1[53], dots3_1[52], dots3_1[25], clr4, coef_refl4, coef_transp4, true, 206, number_of_lights3 };
    trigs[206] = { dots3_1[26], dots3_1[25], dots3_1[52], clr4, coef_refl4, coef_transp4, true, 205, number_of_lights3 };

    return 0;

}

__host__ hit ray_cpu(vec3 pos, vec3 dir) {
    int k, k_min = -1;
    double ts_min = 0.0;
    for (k = 0; k < N; k++) {
        vec3 e1 = diff(trigs[k].b, trigs[k].a);
        vec3 e2 = diff(trigs[k].c, trigs[k].a);
        vec3 p = prod(dir, e2);
        double div = dot(p, e1);
        if (fabs(div) < 1e-10)
            continue;
        vec3 t = diff(pos, trigs[k].a);
        double u = dot(p, t) / div;
        if (u < 0.0 || u > 1.0)
            continue;
        vec3 q = prod(t, e1);
        double v = dot(q, dir) / div;
        if (v < 0.0 || v + u > 1.0)
            continue;
        double ts = dot(q, e2) / div;
        if (ts < 0.0)
            continue;

        if (k_min == -1 || ts < ts_min)
        {
            k_min = k;
            ts_min = ts;
        }
    }

    if (k_min == -1)
        return { {0, 0, 0}, {0, 0, 0}, -1 };

    vec3 norma = prod(diff(trigs[k_min].b, trigs[k_min].a), diff(trigs[k_min].c, trigs[k_min].a));
    norma = norm(norma);
    vec3 place = add(pos, { dir.x * ts_min, dir.y * ts_min, dir.z * ts_min });
    return { place, norma, k_min };
}

__host__ int ray_trace_cpu(ray* rays, int size_of_rays, ray* rays_out, float4* data) {
    int ret_num = 0;

    for (int i = 0; i < size_of_rays; i++) {

        hit cur = ray_cpu(rays[i].pos, rays[i].dir);

        if (cur.num_of_trig == -1) {
            continue;
        }

        double4 res = { 0.0, 0.0, 0.0, 255 };

        double4 clr_d = {
               trigs[cur.num_of_trig].color.x * (1.0 - trigs[cur.num_of_trig].coef_transp),
               trigs[cur.num_of_trig].color.y * (1.0 - trigs[cur.num_of_trig].coef_transp),
               trigs[cur.num_of_trig].color.z * (1.0 - trigs[cur.num_of_trig].coef_transp),
               255
        };

        // обработка пола

        if (trigs[cur.num_of_trig].is_floor) {

            vec3 A = trigs[0].b;
            vec3 B = trigs[0].a;
            B = diff(B, A);
            vec3 C = trigs[0].c;
            C = diff(C, A);

            vec3 point = diff(cur.pos, A);

            double alpha = (point.x * B.y - point.y * B.x) / (C.x * B.y - C.y * B.x);
            double beta = (point.x * C.y - point.y * C.x) / (B.x * C.y - B.y * C.x);

            int xp = alpha * w_f;
            int yp = beta * h_f;
            xp = max(0, min(xp, w_f - 1));
            yp = max(0, min(yp, h_f - 1));


            clr_d = {
                (double)floor_text[yp * w_f + xp].x / 255.0 * trigs[cur.num_of_trig].clr_floor.x,
                (double)floor_text[yp * w_f + xp].y / 255.0 * trigs[cur.num_of_trig].clr_floor.y,
                (double)floor_text[yp * w_f + xp].z / 255.0 * trigs[cur.num_of_trig].clr_floor.z,
                255.0
            };
        }

        // обработка источников света на ребре

        bool is_light = false;

        if (trigs[cur.num_of_trig].is_edge && dot(cur.normal, rays[i].dir) > 0.0) {
            
            double radius =
                sqrt((trigs[cur.num_of_trig].b.x - trigs[trigs[cur.num_of_trig].pair].a.x) *
                    (trigs[cur.num_of_trig].b.x - trigs[trigs[cur.num_of_trig].pair].a.x) +
                    (trigs[cur.num_of_trig].b.y - trigs[trigs[cur.num_of_trig].pair].a.y) *
                    (trigs[cur.num_of_trig].b.y - trigs[trigs[cur.num_of_trig].pair].a.y) +
                    (trigs[cur.num_of_trig].b.z - trigs[trigs[cur.num_of_trig].pair].a.z) *
                    (trigs[cur.num_of_trig].b.z - trigs[trigs[cur.num_of_trig].pair].a.z)) / 2.0 * 0.7;

            vec3 point1 = add(trigs[cur.num_of_trig].b, trigs[trigs[cur.num_of_trig].pair].a);
            point1 = { point1.x / 2, point1.y / 2, point1.z / 2 };

            vec3 point2 = add(trigs[cur.num_of_trig].a, trigs[cur.num_of_trig].c);
            point2 = { point2.x / 2, point2.y / 2, point2.z / 2 };

            double shift_x = (point2.x - point1.x) / (trigs[cur.num_of_trig].number_of_lights + 1);
            double shift_y = (point2.y - point1.y) / (trigs[cur.num_of_trig].number_of_lights + 1);
            double shift_z = (point2.z - point1.z) / (trigs[cur.num_of_trig].number_of_lights + 1);

            vec3 cur_shift = point1;

            cur_shift.x = cur_shift.x + shift_x;
            cur_shift.y = cur_shift.y + shift_y;
            cur_shift.z = cur_shift.z + shift_z;

            double len;

            
            
            for (int k = 1; k <= trigs[cur.num_of_trig].number_of_lights; k++) {
                len = sqrt((cur_shift.x - cur.pos.x) * (cur_shift.x - cur.pos.x) +
                    (cur_shift.y - cur.pos.y) * (cur_shift.y - cur.pos.y) +
                    (cur_shift.z - cur.pos.z) * (cur_shift.z - cur.pos.z));
                if (len <= radius) {
                    is_light = true;
                    break;
                }
                cur_shift.x = cur_shift.x + shift_x;
                cur_shift.y = cur_shift.y + shift_y;
                cur_shift.z = cur_shift.z + shift_z;
            }
        }

        if (dot(cur.normal, rays[i].dir) > 0) {
            cur.normal = diff({ 0, 0, 0 }, cur.normal);
        }

        // обработка источников света вокруг

        for (int k = 0;k < light_numb;k++) {

            hit tmp = ray_cpu(lights[k].pos, norm(diff(cur.pos, lights[k].pos)));

            if (cur.num_of_trig == tmp.num_of_trig) {

                //рассеянная составляющая света

                vec3 N_d = cur.normal;
                vec3 L_d = norm(diff(lights[k].pos, cur.pos));
                double d = sqrt(dot(diff(cur.pos, lights[k].pos), diff(cur.pos, lights[k].pos)));
                d = sqrt(d) / 2;

                res = {
                    res.x + clr_d.x * lights[k].color.x * dot(N_d, L_d) / d,
                    res.y + clr_d.y * lights[k].color.y * dot(N_d, L_d) / d,
                    res.z + clr_d.z * lights[k].color.z * dot(N_d, L_d) / d,
                    255
                };

                //зеркальная составляющая света

                vec3 L_s = norm(diff(cur.pos, lights[k].pos));
                vec3 R_s = {
                     L_s.x - 2 * dot(cur.normal, L_s) * cur.normal.x,
                     L_s.y - 2 * dot(cur.normal, L_s) * cur.normal.y,
                     L_s.z - 2 * dot(cur.normal, L_s) * cur.normal.z,
                };

                R_s = norm(R_s);
                vec3 S_s = norm(diff(rays[i].pos, cur.pos));
                double k_s = trigs[cur.num_of_trig].coef_refl;

                res = {
                    res.x + clr_d.x * k_s * lights[k].color.x * pow(dot(R_s, S_s), 9) / d,
                    res.y + clr_d.y * k_s * lights[k].color.y * pow(dot(R_s, S_s), 9) / d,
                    res.z + clr_d.z * k_s * lights[k].color.z * pow(dot(R_s, S_s), 9) / d,
                    255
                };
            }
        }

        // фоновая составляющая

        double4 ambient_light = { 0.3, 0.3, 0.3, 255 };

        res = {
              res.x + clr_d.x * ambient_light.x,
              res.y + clr_d.y * ambient_light.y,
              res.z + clr_d.z * ambient_light.z,
              255
        };

        if (is_light) {
            res = { 1.0, 1.0, 1.0, 255 };
        }

        //  учёт значения

        res = {
              res.x * rays[i].coef,
              res.y * rays[i].coef,
              res.z * rays[i].coef,
              255
        };

        data[rays[i].id].x = data[rays[i].id].x + res.x;
        data[rays[i].id].y = data[rays[i].id].y + res.y;
        data[rays[i].id].z = data[rays[i].id].z + res.z;

        vec3 shift;

        // отражённый луч

        if (trigs[cur.num_of_trig].coef_refl > 0) {

            vec3 R = {
                     rays[i].dir.x - 2 * dot(cur.normal, rays[i].dir) * cur.normal.x,
                     rays[i].dir.y - 2 * dot(cur.normal, rays[i].dir) * cur.normal.y,
                     rays[i].dir.z - 2 * dot(cur.normal, rays[i].dir) * cur.normal.z
            };
            R = norm(R);

            shift = {
                cur.pos.x + R.x * 0.001,
                cur.pos.y + R.y * 0.001,
                cur.pos.z + R.z * 0.001
            };

            rays_out[ret_num] = { shift, R, rays[i].id, rays[i].coef * trigs[cur.num_of_trig].coef_refl };
            ret_num++;
        }

        // луч, прошедший насквозь

        if (trigs[cur.num_of_trig].coef_transp > 0) {

            vec3 shift = {
                cur.pos.x + rays[i].dir.x * 0.001,
                cur.pos.y + rays[i].dir.y * 0.001,
                cur.pos.z + rays[i].dir.z * 0.001
            };

            rays_out[ret_num] = { shift, rays[i].dir, rays[i].id, rays[i].coef * trigs[cur.num_of_trig].coef_transp };
            ret_num++;
        }
    }

    return ret_num;
}

__host__ void init_rays_n_data_c(ray* rays, float4* data, vec3 pc, vec3 pv, int w, int h, double angle) {

    double dw = 2.0 / (w - 1.0);
    double dh = 2.0 / (h - 1.0);
    double z = 1.0 / tan(angle * M_PI / 360.0);
    vec3 bz = norm(diff(pv, pc));
    vec3 bx = norm(prod(bz, { 0.0, 0.0, 1.0 }));
    vec3 by = norm(prod(bx, bz));
    for (int i = 0; i < w; i++)
        for (int j = 0; j < h; j++) {

            vec3 v = { -1.0 + dw * i, (-1.0 + dh * j) * h / w, z };
            vec3 dir = mult(bx, by, bz, v);
            dir = norm(dir);

            rays[i * h + j] = { pc, dir, (h - 1 - j) * w + i, 1.0 };
            data[i * h + j] = { 0.0, 0.0, 0.0, 255 };

        }

}

__host__ void write_data_c(uchar4* data2, float4* data1, int w, int h, int sqrt_ssaa) {

    for (int i = 0; i < w; i++)
        for (int j = 0; j < h; j++) {
            //ssaa
            double4 cur = { 0.0, 0.0, 0.0, 255.0 };
            for (int i1 = i * sqrt_ssaa; i1 < (i + 1) * sqrt_ssaa; i1++) {
                for (int j1 = j * sqrt_ssaa; j1 < (j + 1) * sqrt_ssaa; j1++) {
                    if (j1 * w * sqrt_ssaa + i1 >= w * h * sqrt_ssaa * sqrt_ssaa) {
                        break;
                    }
                    cur = {
                        cur.x + data1[j1 * w * sqrt_ssaa + i1].x,
                        cur.y + data1[j1 * w * sqrt_ssaa + i1].y,
                        cur.z + data1[j1 * w * sqrt_ssaa + i1].z,
                        255.0
                    };
                }
            }

            data2[j * w + i] = {
                (uchar)min(255.0 * cur.x / sqrt_ssaa / sqrt_ssaa, 255.0),
                (uchar)min(255.0 * cur.y / sqrt_ssaa / sqrt_ssaa, 255.0),
                (uchar)min(255.0 * cur.z / sqrt_ssaa / sqrt_ssaa, 255.0),
                255
            };

        }

}

__host__ void render_cpu(vec3 pc, vec3 pv, int w, int h, double angle, uchar4* data, int max_rec, int sqrt_ssaa) {
    w = w * sqrt_ssaa;
    h = h * sqrt_ssaa;

    float4* data1 = (float4*)malloc(sizeof(float4) * w * h);

    ray* rays = (ray*)malloc(sizeof(ray) * w * h);
    init_rays_n_data_c(rays, data1, pc, pv, w, h, angle);

    int size_of_rays = w * h;

    for (int i = 0;i < max_rec;i++) {
        if (size_of_rays < 1) {
            break;
        }
        ray* rays_out = (ray*)malloc(sizeof(ray) * size_of_rays * 2);
        size_of_rays = ray_trace_cpu(rays, size_of_rays, rays_out, data1);
        free(rays);
        rays = rays_out;
    }

    w = w / sqrt_ssaa;
    h = h / sqrt_ssaa;

    write_data_c(data, data1, w, h, sqrt_ssaa);
    free(rays);
    free(data1);
}

__device__ hit ray_gpu(trig* trigs, vec3 pos, vec3 dir, int N) {
    int k, k_min = -1;
    double ts_min = 0.0;
    for (k = 0; k < N; k++) {
        vec3 e1 = diff(trigs[k].b, trigs[k].a);
        vec3 e2 = diff(trigs[k].c, trigs[k].a);
        vec3 p = prod(dir, e2);
        double div = dot(p, e1);
        if (fabs(div) < 1e-10)
            continue;
        vec3 t = diff(pos, trigs[k].a);
        double u = dot(p, t) / div;
        if (u < 0.0 || u > 1.0)
            continue;
        vec3 q = prod(t, e1);
        double v = dot(q, dir) / div;
        if (v < 0.0 || v + u > 1.0)
            continue;
        double ts = dot(q, e2) / div;
        if (ts < 0.0)
            continue;

        if (k_min == -1 || ts < ts_min)
        {
            k_min = k;
            ts_min = ts;
        }
    }

    if (k_min == -1)
        return { {0, 0, 0}, {0, 0, 0}, -1 };

    vec3 norma = prod(diff(trigs[k_min].b, trigs[k_min].a), diff(trigs[k_min].c, trigs[k_min].a));
    norma = norm(norma);
    vec3 place = add(pos, { dir.x * ts_min, dir.y * ts_min, dir.z * ts_min });
    return { place, norma, k_min };
}

__global__ void ray_trace_gpu(trig* trigs, int N, light* lights, int light_numb, ray* rays, int size_of_rays, ray* rays_out, int* size_of_rays_out, float4* data, uchar4* floor_text, int w_f, int h_f) {
    int idx = blockDim.x * blockIdx.x + threadIdx.x;
    int offsetx = blockDim.x * gridDim.x;

    for (int i = idx; i < size_of_rays; i += offsetx) {

        hit cur = ray_gpu(trigs, rays[i].pos, rays[i].dir, N);

        if (cur.num_of_trig == -1) {
            continue;
        }

        double4 res = { 0.0, 0.0, 0.0, 255 };

        double4 clr_d = {
               trigs[cur.num_of_trig].color.x * (1.0 - trigs[cur.num_of_trig].coef_transp),
               trigs[cur.num_of_trig].color.y * (1.0 - trigs[cur.num_of_trig].coef_transp),
               trigs[cur.num_of_trig].color.z * (1.0 - trigs[cur.num_of_trig].coef_transp),
               255
        };

        // обработка пола

        if (trigs[cur.num_of_trig].is_floor) {

            vec3 A = trigs[0].b;
            vec3 B = trigs[0].a;
            B = diff(B, A);
            vec3 C = trigs[0].c;
            C = diff(C, A);

            vec3 point = diff(cur.pos, A);

            double alpha = (point.x * B.y - point.y * B.x) / (C.x * B.y - C.y * B.x);
            double beta = (point.x * C.y - point.y * C.x) / (B.x * C.y - B.y * C.x);

            int xp = alpha * w_f;
            int yp = beta * h_f;
            xp = max(0, min(xp, w_f - 1));
            yp = max(0, min(yp, h_f - 1));


            clr_d = {
                (double)floor_text[yp * w_f + xp].x / 255.0 * trigs[cur.num_of_trig].clr_floor.x,
                (double)floor_text[yp * w_f + xp].y / 255.0 * trigs[cur.num_of_trig].clr_floor.y,
                (double)floor_text[yp * w_f + xp].z / 255.0 * trigs[cur.num_of_trig].clr_floor.z,
                255.0
            };
        }

        // обработка источников света на ребре

        bool is_light = false;

        if (trigs[cur.num_of_trig].is_edge && dot(cur.normal, rays[i].dir) > 0.0) {

            double radius = 
                sqrt((trigs[cur.num_of_trig].b.x - trigs[trigs[cur.num_of_trig].pair].a.x) * 
                (trigs[cur.num_of_trig].b.x - trigs[trigs[cur.num_of_trig].pair].a.x) + 
                (trigs[cur.num_of_trig].b.y - trigs[trigs[cur.num_of_trig].pair].a.y) *
                (trigs[cur.num_of_trig].b.y - trigs[trigs[cur.num_of_trig].pair].a.y) +
                (trigs[cur.num_of_trig].b.z - trigs[trigs[cur.num_of_trig].pair].a.z) *
                (trigs[cur.num_of_trig].b.z - trigs[trigs[cur.num_of_trig].pair].a.z)) / 2.0 * 0.7;

            vec3 point1 = add(trigs[cur.num_of_trig].b, trigs[trigs[cur.num_of_trig].pair].a);
            point1 = { point1.x / 2, point1.y / 2, point1.z / 2 };

            vec3 point2 = add(trigs[cur.num_of_trig].a, trigs[cur.num_of_trig].c);
            point2 = { point2.x / 2, point2.y / 2, point2.z / 2 };

            double shift_x = (point2.x - point1.x) / (trigs[cur.num_of_trig].number_of_lights + 1);
            double shift_y = (point2.y - point1.y) / (trigs[cur.num_of_trig].number_of_lights + 1);
            double shift_z = (point2.z - point1.z) / (trigs[cur.num_of_trig].number_of_lights + 1);

            vec3 cur_shift = point1;

            cur_shift.x = cur_shift.x + shift_x;
            cur_shift.y = cur_shift.y + shift_y;
            cur_shift.z = cur_shift.z + shift_z;

            double len;

            for (int k = 1; k <= trigs[cur.num_of_trig].number_of_lights; k++) {
                len = sqrt((cur_shift.x - cur.pos.x) * (cur_shift.x - cur.pos.x) +
                    (cur_shift.y - cur.pos.y) * (cur_shift.y - cur.pos.y) +
                    (cur_shift.z - cur.pos.z) * (cur_shift.z - cur.pos.z));
                if (len <= radius) {
                    is_light = true;
                    break;
                }
                cur_shift.x = cur_shift.x + shift_x;
                cur_shift.y = cur_shift.y + shift_y;
                cur_shift.z = cur_shift.z + shift_z;
            }
        }

        if (dot(cur.normal, rays[i].dir) > 0) {
            cur.normal = diff({ 0, 0, 0 }, cur.normal);
        }

        // обработка источников света вокруг

        for (int k = 0;k < light_numb;k++) {

            hit tmp = ray_gpu(trigs, lights[k].pos, norm(diff(cur.pos, lights[k].pos)), N);

            if (cur.num_of_trig == tmp.num_of_trig) {

                //рассеянная составляющая света

                vec3 N_d = cur.normal;
                vec3 L_d = norm(diff(lights[k].pos, cur.pos));
                double d = sqrt(dot(diff(cur.pos, lights[k].pos), diff(cur.pos, lights[k].pos)));
                d = sqrt(d) / 2;

                res = {
                    res.x + clr_d.x * lights[k].color.x * dot(N_d, L_d) / d,
                    res.y + clr_d.y * lights[k].color.y * dot(N_d, L_d) / d,
                    res.z + clr_d.z * lights[k].color.z * dot(N_d, L_d) / d,
                    255
                };

                //зеркальная составляющая света

                vec3 L_s = norm(diff(cur.pos, lights[k].pos));
                vec3 R_s = {
                     L_s.x - 2 * dot(cur.normal, L_s) * cur.normal.x,
                     L_s.y - 2 * dot(cur.normal, L_s) * cur.normal.y,
                     L_s.z - 2 * dot(cur.normal, L_s) * cur.normal.z,
                };

                R_s = norm(R_s);
                vec3 S_s = norm(diff(rays[i].pos, cur.pos));
                double k_s = trigs[cur.num_of_trig].coef_refl;

                res = {
                    res.x + clr_d.x * k_s * lights[k].color.x * pow(dot(R_s, S_s), 9) / d,
                    res.y + clr_d.y * k_s * lights[k].color.y * pow(dot(R_s, S_s), 9) / d,
                    res.z + clr_d.z * k_s * lights[k].color.z * pow(dot(R_s, S_s), 9) / d,
                    255
                };
            }
        }

        // фоновая составляющая

        double4 ambient_light = { 0.3, 0.3, 0.3, 255 };

        res = {
              res.x + clr_d.x * ambient_light.x,
              res.y + clr_d.y * ambient_light.y,
              res.z + clr_d.z * ambient_light.z,
              255
        };

        if (is_light) {
            res = { 1.0, 1.0, 1.0, 255 };
        }

        //  учёт значения

        res = {
              res.x * rays[i].coef,
              res.y * rays[i].coef,
              res.z * rays[i].coef,
              255
        };

        atomicAdd(&data[rays[i].id].x, res.x);
        atomicAdd(&data[rays[i].id].y, res.y);
        atomicAdd(&data[rays[i].id].z, res.z);

        vec3 shift;

        // отражённый луч

        if (trigs[cur.num_of_trig].coef_refl > 0) {

            vec3 R = {
                     rays[i].dir.x - 2 * dot(cur.normal, rays[i].dir) * cur.normal.x,
                     rays[i].dir.y - 2 * dot(cur.normal, rays[i].dir) * cur.normal.y,
                     rays[i].dir.z - 2 * dot(cur.normal, rays[i].dir) * cur.normal.z
            };
            R = norm(R);

            shift = {
                cur.pos.x + R.x * 0.001,
                cur.pos.y + R.y * 0.001,
                cur.pos.z + R.z * 0.001
            };

            rays_out[atomicAdd(size_of_rays_out, 1)] = { shift, R, rays[i].id, rays[i].coef * trigs[cur.num_of_trig].coef_refl };
        }

        // луч, прошедший насквозь

        if (trigs[cur.num_of_trig].coef_transp > 0) {

            vec3 shift = {
                cur.pos.x + rays[i].dir.x * 0.001,
                cur.pos.y + rays[i].dir.y * 0.001,
                cur.pos.z + rays[i].dir.z * 0.001
            };

            rays_out[atomicAdd(size_of_rays_out, 1)] = { shift, rays[i].dir, rays[i].id, rays[i].coef * trigs[cur.num_of_trig].coef_transp };
        }
    }
}

__global__ void init_rays_n_data(ray* rays, float4* data, vec3 pc, vec3 pv, int w, int h, double angle) {
    int idx = blockDim.x * blockIdx.x + threadIdx.x;
    int idy = blockDim.y * blockIdx.y + threadIdx.y;
    int offsetx = blockDim.x * gridDim.x;
    int offsety = blockDim.y * gridDim.y;

    double dw = 2.0 / (w - 1.0);
    double dh = 2.0 / (h - 1.0);
    double z = 1.0 / tan(angle * M_PI / 360.0);
    vec3 bz = norm(diff(pv, pc));
    vec3 bx = norm(prod(bz, { 0.0, 0.0, 1.0 }));
    vec3 by = norm(prod(bx, bz));
    for (int i = idx; i < w; i += offsetx)
        for (int j = idy; j < h; j += offsety) {

            vec3 v = { -1.0 + dw * i, (-1.0 + dh * j) * h / w, z };
            vec3 dir = mult(bx, by, bz, v);
            dir = norm(dir);

            rays[i * h + j] = { pc, dir, (h - 1 - j) * w + i, 1.0 };
            data[i * h + j] = { 0.0, 0.0, 0.0, 255 };

        }

}

__global__ void write_data(uchar4* data2, float4* data1, int w, int h, int sqrt_ssaa) {
    int idx = blockDim.x * blockIdx.x + threadIdx.x;
    int idy = blockDim.y * blockIdx.y + threadIdx.y;
    int offsetx = blockDim.x * gridDim.x;
    int offsety = blockDim.y * gridDim.y;

    for (int i = idx; i < w; i += offsetx)
        for (int j = idy; j < h; j += offsety) {
            //ssaa
            double4 cur = {0.0, 0.0, 0.0, 255.0};
            for (int i1 = i * sqrt_ssaa; i1 < (i + 1) * sqrt_ssaa; i1++) {
                for (int j1 = j * sqrt_ssaa; j1 < (j + 1) * sqrt_ssaa; j1++) {
                    if (j1 * w * sqrt_ssaa + i1 >= w * h * sqrt_ssaa * sqrt_ssaa) {
                        break;
                    }
                    cur = {
                        cur.x + data1[j1 * w * sqrt_ssaa + i1].x,
                        cur.y + data1[j1 * w * sqrt_ssaa + i1].y,
                        cur.z + data1[j1 * w * sqrt_ssaa + i1].z,
                        255.0
                    };
                }
            }

            data2[j * w + i] = {
                (uchar)min(255.0 * cur.x / sqrt_ssaa / sqrt_ssaa, 255.0),
                (uchar)min(255.0 * cur.y / sqrt_ssaa / sqrt_ssaa, 255.0),
                (uchar)min(255.0 * cur.z / sqrt_ssaa / sqrt_ssaa, 255.0),
                255
            };

        }

}

void render_gpu(trig* trigs1, light* lights1, vec3 pc, vec3 pv, int w, int h, double angle, uchar4* data, int max_rec, int sqrt_ssaa, uchar4* floor_text1) {
    uchar4* data2;
    CSC(cudaMalloc(&data2, sizeof(uchar4) * w * h));

    w = w * sqrt_ssaa;
    h = h * sqrt_ssaa;
    
    float4* data1;
    CSC(cudaMalloc(&data1, sizeof(float4) * w * h));

    ray* rays;
    CSC(cudaMalloc(&rays, sizeof(ray) * w * h));
    init_rays_n_data << < dim3(16, 16), dim3(16, 16) >> > (rays, data1, pc, pv, w, h, angle);

    int size_of_rays = w * h;
    int* zero = (int*)malloc(sizeof(int));
    zero[0] = 0;

    for (int i = 0;i < max_rec;i++) {
        if (size_of_rays < 1) {
            break;
        }
        ray* rays_out;
        CSC(cudaMalloc(&rays_out, sizeof(ray) * size_of_rays * 2));
        int* size_of_rays_out;
        CSC(cudaMalloc(&size_of_rays_out, sizeof(int)));
        CSC(cudaMemcpy(size_of_rays_out, zero, sizeof(int), cudaMemcpyHostToDevice));
        ray_trace_gpu << < 512, 512 >> > (trigs1, N, lights1, light_numb, rays, size_of_rays, rays_out, size_of_rays_out, data1, floor_text1, w_f, h_f);
        CSC(cudaFree(rays));
        rays = rays_out;
        cudaMemcpy(&size_of_rays, size_of_rays_out, sizeof(int), cudaMemcpyDeviceToHost);
        CSC(cudaFree(size_of_rays_out));
    }

    w = w / sqrt_ssaa;
    h = h / sqrt_ssaa;

    write_data << < dim3(16, 16), dim3(16, 16) >> > (data2, data1, w, h , sqrt_ssaa);
    cudaMemcpy(data, data2, sizeof(uchar4) * w * h, cudaMemcpyDeviceToHost);
    CSC(cudaFree(rays));
    CSC(cudaFree(data1));
    CSC(cudaFree(data2));
}


int main() {

    trigs = (trig*)malloc(sizeof(trig) * N);

    int k = 128;

    char* res_path = "res/%03d.data";

    int w = 640;
    int h = 480;
    double angle = 120.0;

    double r_0_c = 7.0;
    double z_0_c = 3.0;
    double phi_0_c = 0.0;

    double A_r_c = 2.0;
    double A_z_c = 1.0;

    double w_r_c = 2.0;
    double w_z_c = 6.0;
    double w_phi_c = 1.0;

    double p_r_c = 0.0;
    double p_z_c = 0.0;


    double r_0_n = 2.0;
    double z_0_n = 0.0;
    double phi_0_n = 0.0;

    double A_r_n = 0.5;
    double A_z_n = 0.1;

    double w_r_n = 1.0;
    double w_z_n = 4.0;
    double w_phi_n = 1.0;

    double p_r_n = 0.0;
    double p_z_n = 0.0;

    vec3 c1 = { -3, -3, 4 }; // координаты центра
    double4 clr1 = { 1.0, 0.0, 0.0, 255.0 }; // цвет
    double r1 = sqrt(3); // радиус описанной сферы
    double coef_refl1 = 0.5; // коэффициент отражения
    double coef_transp1 = 0.5; // коэффициент прозрачности
    int number_of_lights1 = 4; // количество источников света на ребре

    vec3 c2 = { 0, 0, 3 };
    double4 clr2 = { 0.0, 1.0, 0.0, 255.0 };
    double r2 = sqrt(2);
    double coef_refl2 = 0.5;
    double coef_transp2 = 0.5;
    int number_of_lights2 = 4;

    vec3 c3 = { 3, 3, 4 };
    double4 clr3 = { 0.0, 0.0, 0.7, 255.0 };
    double r3 = 2;
    double coef_refl3 = 0.5;
    double coef_transp3 = 0.5;
    int number_of_lights3 = 4;

    // точки пола
    vec3 pnt1 = { -5.0, -5.0, 3.0 };
    vec3 pnt2 = { -5.0, 5.0, 1.0 };
    vec3 pnt3 = { 5.0, 5.0, 3.0 };
    vec3 pnt4 = { 5.0, -5.0, 1.0 };
    double4 clr_fl = { 0.5, 0.5, 0.5, 255.0 };
    double coef_fl = 0.5; // коэффициент отражения
    char* floor_path = "in.data";

    light_numb = 2;

    int max_rec = 6;
    int sqrt_ssaa = 2;

    bool use_gpu;
    bool read_input = true;

    /*for (int i = 1; i < argc; ++i) {
        if (strcmp(argv[i], "--cpu") == 0) {
            use_gpu = false;
        }
        else if (strcmp(argv[i], "--gpu") == 0) {
            use_gpu = true;
        }
        else if (strcmp(argv[i], "--default") == 0) {
            read_input = false;
        }
        else {
            printf("Unknown key: %s\n", argv[i]);
            return 0;
        }
    }*/

    use_gpu = true;
    read_input = false;

    if (read_input) {

        scanf("%d", k);

        char* res_path = "res/%03d.data";

        scanf("%d%d%lf", &w, &h, &angle);

        scanf("%lf%lf%lf", &r_0_c, &z_0_c, &phi_0_c);
        scanf("%lf%lf", &A_r_c, &A_z_c);
        scanf("%lf%lf%lf", &w_r_c, &w_z_c, &w_phi_c);
        scanf("%lf%lf", &p_r_c, &p_z_c);

        scanf("%lf%lf%lf", &r_0_n, &z_0_n, &phi_0_n);
        scanf("%lf%lf", &A_r_n, &A_z_n);
        scanf("%lf%lf%lf", &w_r_n, &w_z_n, &w_phi_n);
        scanf("%lf%lf", &p_r_n, &p_z_n);

        scanf("%lf%lf%lf", &c1.x, &c1.y, &c1.z);
        scanf("%lf%lf%lf", &clr1.x, &clr1.y, &clr1.z);
        scanf("%lf%lf%lf%d", &r1, &coef_refl1, &coef_transp1, &number_of_lights1);

        scanf("%lf%lf%lf", &c2.x, &c2.y, &c2.z);
        scanf("%lf%lf%lf", &clr2.x, &clr2.y, &clr2.z);
        scanf("%lf%lf%lf%d", &r2, &coef_refl2, &coef_transp2, &number_of_lights2);

        scanf("%lf%lf%lf", &c3.x, &c3.y, &c3.z);
        scanf("%lf%lf%lf", &clr3.x, &clr3.y, &clr3.z);
        scanf("%lf%lf%lf%d", &r3, &coef_refl3, &coef_transp3, &number_of_lights3);

        scanf("%lf%lf%lf", &pnt1.x, &pnt1.y, &pnt1.z);
        scanf("%lf%lf%lf", &pnt2.x, &pnt2.y, &pnt2.z);
        scanf("%lf%lf%lf", &pnt3.x, &pnt3.y, &pnt3.z);
        scanf("%lf%lf%lf", &pnt4.x, &pnt4.y, &pnt4.z);
        scanf("%lf%lf%lf", &clr_fl.x, &clr_fl.y, &clr_fl.z);
        scanf("%lf", &coef_fl);
        char* floor_path = "a";

        if (build_space(c1, clr1, r1, coef_refl1, coef_transp1, number_of_lights1,
            c2, clr2, r2, coef_refl2, coef_transp2, number_of_lights2,
            c3, clr3, r3, coef_refl3, coef_transp3, number_of_lights3,
            pnt1, pnt2, pnt3, pnt4, clr_fl, coef_fl, floor_path) == 2) {

            fprintf(stderr, "Что то не так с текстурой");
            return 2;
        }


        scanf("%d", &light_numb);
        lights = (light*)malloc(sizeof(light) * light_numb);
        for (int i = 0; i < light_numb; i++) {
            scanf("%lf%lf%lf", &lights[i].pos.x, &lights[i].pos.y, &lights[i].pos.z);
            scanf("%lf%lf%lf", &lights[i].color.x, &lights[i].color.y, &lights[i].color.z);
        }

        scanf("%d", &max_rec);
        scanf("%d", &sqrt_ssaa);

    }
    else {

        if (build_space(c1, clr1, r1, coef_refl1, coef_transp1, number_of_lights1,
            c2, clr2, r2, coef_refl2, coef_transp2, number_of_lights2,
            c3, clr3, r3, coef_refl3, coef_transp3, number_of_lights3,
            pnt1, pnt2, pnt3, pnt4, clr_fl, coef_fl, floor_path) == 2) {

            fprintf(stderr, "Что то не так с текстурой");
            return 2;
        }

        lights = (light*)malloc(sizeof(light) * light_numb);
        for (int i = 0; i < light_numb; i++) {
            lights[i].pos.x = -10.0;
            lights[i].pos.y = 0.0;
            lights[i].pos.z = 10.0;

            lights[i].color.x = 1.0;
            lights[i].color.y = 1.0;
            lights[i].color.z = 1.0;
        }

        lights[1].pos.x = 1.0;
        lights[1].pos.y = -10.0;
        lights[1].pos.z = 10.0;

        lights[1].color.x = 1.0;
        lights[1].color.y = 1.0;
        lights[1].color.z = 1.0;


    }

    trig* trigs1;
    light* lights1;
    uchar4* floor_text1;
    if (use_gpu) {
        CSC(cudaMalloc(&trigs1, sizeof(trig) * N));
        CSC(cudaMemcpy(trigs1, trigs, sizeof(trig) * N, cudaMemcpyHostToDevice));

        CSC(cudaMalloc(&lights1, sizeof(light) * light_numb));
        CSC(cudaMemcpy(lights1, lights, sizeof(light) * light_numb, cudaMemcpyHostToDevice));

        CSC(cudaMalloc(&floor_text1, sizeof(uchar4) * w_f * h_f));
        CSC(cudaMemcpy(floor_text1, floor_text, sizeof(uchar4) * w_f * h_f, cudaMemcpyHostToDevice));
    }

    char buff[256];
    uchar4* data = (uchar4*)malloc(sizeof(uchar4) * w * h);
    vec3 pc, pv;
    double t;

    for (int i = 0; i < k; i++) {

        t = 2 * M_PI * i / (k - 1);

        pc = to_normal(
            r_0_c + A_r_c * sin(w_r_c * t + p_r_c),
            phi_0_c + w_phi_c * t,
            z_0_c + A_z_c * sin(w_z_c * t + p_z_c)
        );

        pv = to_normal(
            r_0_n + A_r_n * sin(w_r_n * t + p_r_n),
            phi_0_n + w_phi_n * t,
            z_0_n + A_z_n * sin(w_z_n * t + p_z_n)
        );

        if (use_gpu) {
            render_gpu(trigs1, lights1, pc, pv, w, h, angle, data, max_rec, sqrt_ssaa, floor_text1);
        }
        else {
            render_cpu(pc, pv, w, h, angle, data, max_rec, sqrt_ssaa);
        }

        sprintf(buff, res_path, i);
        printf("%d: %s\n", i, buff);

        FILE* out = fopen(buff, "wb");

        if (out == NULL) {
            fprintf(stderr, "Что-то не так с буфером вывода");
            return 2;
        }

        fwrite(&w, sizeof(int), 1, out);
        fwrite(&h, sizeof(int), 1, out);
        fwrite(data, sizeof(uchar4), w * h, out);
        fclose(out);
    }
    if (use_gpu) {
        CSC(cudaFree(lights1));
        CSC(cudaFree(trigs1));
    }
    free(data);
    return 0;

}